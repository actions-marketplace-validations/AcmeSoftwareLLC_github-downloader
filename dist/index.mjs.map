{"version":3,"file":"index.mjs","names":["options: RequestOptions"],"sources":["../src/utils.ts","../src/main.ts","../src/index.ts"],"sourcesContent":["import { createWriteStream, type Dirent } from \"node:fs\";\nimport { readdir } from \"node:fs/promises\";\nimport { get, type RequestOptions } from \"node:https\";\nimport { join } from \"node:path\";\n\nexport type FileMapping = [string, string];\n\nasync function download(\n\turl: string,\n\toptions: RequestOptions,\n\toutput: string,\n): Promise<void> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst fileStream = createWriteStream(output);\n\t\tfileStream.on(\"error\", reject);\n\n\t\tconst req = get(url, options, (res) => {\n\t\t\tif (res.statusCode && res.statusCode >= 400) {\n\t\t\t\tres.resume();\n\t\t\t\treturn reject(\n\t\t\t\t\tnew Error(`Failed to download ${url} (status ${res.statusCode})`),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tres.pipe(fileStream);\n\n\t\t\tfileStream.on(\"finish\", () => {\n\t\t\t\tfileStream.close((err) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t}\n\t\t\t\t\tresolve();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\treq.on(\"error\", reject);\n\n\t\treq.setTimeout(15000, () => {\n\t\t\treq.destroy(new Error(`Request timed out for ${url}`));\n\t\t});\n\t});\n}\n\nasync function getFiles(directory: string): Promise<string[]> {\n\tconst dirents: Dirent[] = (await readdir(directory, {\n\t\trecursive: true,\n\t\twithFileTypes: true,\n\t})) as unknown as Dirent[];\n\treturn dirents\n\t\t.filter((dirent) => dirent.isFile())\n\t\t.map((dirent) => join(directory, dirent.name));\n}\n\nasync function parseMappings(mappings: string[]): Promise<FileMapping[]> {\n\tconst mappingStr = mappings.join(\"\");\n\treturn Object.entries(JSON.parse(mappingStr));\n}\n\nexport { download, getFiles, parseMappings };\n","import { mkdir } from \"node:fs/promises\";\nimport type { RequestOptions } from \"node:https\";\nimport { dirname, join } from \"node:path\";\nimport { getInput, getMultilineInput, setFailed, summary } from \"@actions/core\";\nimport {\n\tdownload,\n\ttype FileMapping,\n\tgetFiles,\n\tparseMappings,\n} from \"./utils.js\";\n\nexport async function run(): Promise<void> {\n\ttry {\n\t\tconst repo = getInput(\"repo\", { required: true });\n\t\tconst ref = getInput(\"ref\") || \"main\";\n\t\tconst pat = getInput(\"git-pat\");\n\t\tconst outputDir = getInput(\"output-directory\");\n\t\tconst options: RequestOptions = pat\n\t\t\t? { headers: { Authorization: `token ${pat}` } }\n\t\t\t: {};\n\n\t\tconst mappings = await parseMappings(getMultilineInput(\"mappings\"));\n\t\tconst props = { repo, ref, options, outputDir };\n\n\t\tconst downloadedFiles = await downloadMappedFiles(mappings, props);\n\n\t\tconst allFiles = outputDir ? await getFiles(outputDir) : downloadedFiles;\n\n\t\tawait summary\n\t\t\t.addHeading(\"Download Summary\")\n\t\t\t.addTable([\n\t\t\t\t[\n\t\t\t\t\t{ data: \"Description\", header: true },\n\t\t\t\t\t{ data: \"Result\", header: true },\n\t\t\t\t],\n\t\t\t\t[\"Repo\", repo],\n\t\t\t\t[\"Ref\", ref],\n\t\t\t\t[\"Downloaded Files\", downloadedFiles.join(\"\\n\")],\n\t\t\t\t...(outputDir ? [[\"All Files in Output\", allFiles.join(\"\\n\")]] : []),\n\t\t\t])\n\t\t\t.write();\n\t} catch (error) {\n\t\tsetFailed(error instanceof Error ? error.message : String(error));\n\t}\n}\n\ninterface DownloadProps {\n\trepo: string;\n\tref: string;\n\toptions: RequestOptions;\n\toutputDir: string;\n}\n\nasync function downloadMappedFiles(\n\tmappings: FileMapping[],\n\t{ repo, ref, options, outputDir }: DownloadProps,\n): Promise<string[]> {\n\tasync function downloadSingleFile(mapping: FileMapping): Promise<string> {\n\t\tconst [input, output] = mapping;\n\t\tconst outputLocation = outputDir ? join(outputDir, output) : output;\n\t\tconst url = `https://raw.githubusercontent.com/${repo}/${ref}/${input}`;\n\n\t\tawait mkdir(dirname(outputLocation), { recursive: true });\n\t\tawait download(url, options, outputLocation);\n\n\t\tconsole.log(`✅ Downloaded \"${input}\" → \"${outputLocation}\"`);\n\t\treturn outputLocation;\n\t}\n\n\treturn Promise.all(mappings.map(downloadSingleFile));\n}\n","import { run } from \"./main.js\";\n\nrun();\n"],"mappings":";;;;;;;AAOA,eAAe,SACd,KACA,SACA,QACgB;AAChB,QAAO,IAAI,SAAS,SAAS,WAAW;EACvC,MAAM,aAAa,kBAAkB,OAAO;AAC5C,aAAW,GAAG,SAAS,OAAO;EAE9B,MAAM,MAAM,IAAI,KAAK,UAAU,QAAQ;AACtC,OAAI,IAAI,cAAc,IAAI,cAAc,KAAK;AAC5C,QAAI,QAAQ;AACZ,WAAO,uBACN,IAAI,MAAM,sBAAsB,IAAI,WAAW,IAAI,WAAW,GAAG,CACjE;;AAGF,OAAI,KAAK,WAAW;AAEpB,cAAW,GAAG,gBAAgB;AAC7B,eAAW,OAAO,QAAQ;AACzB,SAAI,IACH,QAAO,OAAO,IAAI;AAEnB,cAAS;MACR;KACD;IACD;AAEF,MAAI,GAAG,SAAS,OAAO;AAEvB,MAAI,WAAW,YAAa;AAC3B,OAAI,wBAAQ,IAAI,MAAM,yBAAyB,MAAM,CAAC;IACrD;GACD;;AAGH,eAAe,SAAS,WAAsC;AAK7D,SAJ2B,MAAM,QAAQ,WAAW;EACnD,WAAW;EACX,eAAe;EACf,CAAC,EAEA,QAAQ,WAAW,OAAO,QAAQ,CAAC,CACnC,KAAK,WAAW,KAAK,WAAW,OAAO,KAAK,CAAC;;AAGhD,eAAe,cAAc,UAA4C;CACxE,MAAM,aAAa,SAAS,KAAK,GAAG;AACpC,QAAO,OAAO,QAAQ,KAAK,MAAM,WAAW,CAAC;;;;;AC7C9C,eAAsB,MAAqB;AAC1C,KAAI;EACH,MAAM,OAAO,SAAS,QAAQ,EAAE,UAAU,MAAM,CAAC;EACjD,MAAM,MAAM,SAAS,MAAM,IAAI;EAC/B,MAAM,MAAM,SAAS,UAAU;EAC/B,MAAM,YAAY,SAAS,mBAAmB;EAC9C,MAAMA,UAA0B,MAC7B,EAAE,SAAS,EAAE,eAAe,SAAS,OAAO,EAAE,GAC9C,EAAE;EAKL,MAAM,kBAAkB,MAAM,oBAHb,MAAM,cAAc,kBAAkB,WAAW,CAAC,EACrD;GAAE;GAAM;GAAK;GAAS;GAAW,CAEmB;EAElE,MAAM,WAAW,YAAY,MAAM,SAAS,UAAU,GAAG;AAEzD,QAAM,QACJ,WAAW,mBAAmB,CAC9B,SAAS;GACT,CACC;IAAE,MAAM;IAAe,QAAQ;IAAM,EACrC;IAAE,MAAM;IAAU,QAAQ;IAAM,CAChC;GACD,CAAC,QAAQ,KAAK;GACd,CAAC,OAAO,IAAI;GACZ,CAAC,oBAAoB,gBAAgB,KAAK,KAAK,CAAC;GAChD,GAAI,YAAY,CAAC,CAAC,uBAAuB,SAAS,KAAK,KAAK,CAAC,CAAC,GAAG,EAAE;GACnE,CAAC,CACD,OAAO;UACD,OAAO;AACf,YAAU,iBAAiB,QAAQ,MAAM,UAAU,OAAO,MAAM,CAAC;;;AAWnE,eAAe,oBACd,UACA,EAAE,MAAM,KAAK,SAAS,aACF;CACpB,eAAe,mBAAmB,SAAuC;EACxE,MAAM,CAAC,OAAO,UAAU;EACxB,MAAM,iBAAiB,YAAY,KAAK,WAAW,OAAO,GAAG;EAC7D,MAAM,MAAM,qCAAqC,KAAK,GAAG,IAAI,GAAG;AAEhE,QAAM,MAAM,QAAQ,eAAe,EAAE,EAAE,WAAW,MAAM,CAAC;AACzD,QAAM,SAAS,KAAK,SAAS,eAAe;AAE5C,UAAQ,IAAI,iBAAiB,MAAM,OAAO,eAAe,GAAG;AAC5D,SAAO;;AAGR,QAAO,QAAQ,IAAI,SAAS,IAAI,mBAAmB,CAAC;;;;;ACnErD,KAAK"}